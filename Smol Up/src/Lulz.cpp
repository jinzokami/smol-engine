#include "Lulz.hpp"

std::vector<Vert> uv_sphere(int x_slices, int y_slices)
{
	std::vector<Vert> out;
	std::vector<Vec3> points1;
	for (int i = 0; i < x_slices; i++)
	{
		points1.push_back({ -1, -1, -1 });
	}
	std::vector<Vec3> points2;
	for (int i = 0; i < x_slices; i++)
	{
		points2.push_back({ -1, -1, -1 });
	}

	std::vector<Vec3> circle;
	for (int i = 0; i < x_slices; i++)
	{
		double x = cos(i * ((2.0 * PI) / (double)x_slices));
		double y = 0;
		double z = sin(i * ((2.0 * PI) / (double)x_slices));
		Vec3 thing = { x, y, z };
		circle.push_back(thing);
	}

	//top cap
	//generate the first line of points
	//push triangles connecting each of the points to the cap
	//the points will represent the circle at height 2*(n / y_slices) - 1.0 (giving a value from [1, -1]), where n is the current slice number
	//the radius of the circle will be: cos((n/pi)-pi*2)
	//the points along the circle will be generated by the formula: 
	//	x = cos(m/(2*pi)) * radius(n)
	//	y = ((2.0*(1/y_slices)*n)/y_slices)-1.0
	//	z = sin(m/(2*pi)) * radius(n)
	//where m is the index of the point we are generating
	
	for (int i = 0; i < x_slices; i++)
	{
		double radius = cos((PI/ (double)y_slices)-(PI/2.0));
		double y = sin((PI / (double)y_slices) - (PI / 2.0));
		Vec3 thing = { circle[i].x*radius, y, circle[i].z*radius };
		points1[i] = thing;
	}

	for (int i = 0; i < points1.size(); i++)
	{
		//placeholder uvs
		Vert q = { {0, -1, 0}, {(float)i/((float)x_slices), 0} };
		out.push_back(q);

		Vert o = { points1[i], {(float)i / ((float)x_slices), 1.0f / (float)(y_slices)} };
		out.push_back(o);

		Vert r = { {0, -1, 0}, {(float)(i+1)/ ((float)x_slices), 0} };
		out.push_back(r);

		out.push_back(q);
		out.push_back(o);

		Vert p = { points1[(i+1) % points1.size()], {(float)(i + 1)/ ((float)x_slices), 1.0f / (float)(y_slices)} };
		out.push_back(p);
	}
	std::cout << 0.0 << std::endl;
	std::cout << 1.0f / (float)(y_slices) << std::endl;

	//middle
	for (int i = 2; i < y_slices; i++)
	{
		//generate the second set of points
		for (int j = 0; j < x_slices; j++)
		{
			double radius = cos(i*(PI / (double)y_slices) - (PI / 2));
			double y = sin(i*(PI / (double)y_slices) - (PI / 2));
			Vec3 thing = { circle[j].x*radius, y, circle[j].z*radius };
			points2[j] = thing;
		}
		//connect the second set to the first set
		for (int j = 0; j < x_slices; j++)
		{
			//placeholder uvs
			Vert o = { points1[j], {(float)j/ ((float)x_slices), (float)i/ ((float)y_slices)} };
			out.push_back(o);

			Vert q = { points2[j], {(float)j/ ((float)x_slices), (float)(i + 1)/ ((float)y_slices)} };
			out.push_back(q);

			Vert p = { points1[(j + 1) % points1.size()], {(float)(j + 1)/ ((float)x_slices), (float)i/ ((float)y_slices)} };
			out.push_back(p);

			out.push_back(p);
			out.push_back(q);

			Vert r = { points2[(j + 1) % points2.size()], {(float)(j + 1)/ ((float)x_slices), (float)(i+1)/ ((float)y_slices)} };
			out.push_back(r);
		}
		
		std::cout << (float)i / ((float)y_slices) << std::endl;
		//set the second set to the first set
		for (int j = 0; j < points2.size(); j++)
		{
			points1[j] = points2[j];
		}
	}

	//bottom cap
	//push triangles connecting the first set to the bottom cap
	for (int i = 0; i < points1.size(); i++)
	{
		//placeholder uvs
		Vert o = { points1[i], {(float)i / ((float)x_slices), (float)(y_slices-1) /(float)(y_slices)} };
		out.push_back(o);

		Vert q = { {0, 1, 0}, {(float)i / ((float)x_slices), 1} };
		out.push_back(q);

		Vert p = { points1[(i + 1) % points1.size()], {(float)(i+1) / ((float)x_slices), (float)(y_slices-1) / (float)(y_slices)} };
		out.push_back(p);

		out.push_back(p);
		out.push_back(q);

		Vert r = { {0, 1, 0}, {(float)(i+1) / ((float)x_slices), 1} };
		out.push_back(r);
	}
	std::cout << 1.0 << std::endl;

	return out;
}