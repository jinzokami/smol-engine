Animation System:
#Have support for overriding animations per bone (so you can have a running animation and an aiming animation fire at the same time.)
Structs:

Animation - (AnimationData* animData, Orientation* startingOrientations, float timer = 0) #Maybe support blending between two animations (or animate the transition ourselves)
#Animation (Blending support) - (AnimationData* animData, Animation* previousAnim, float transDuration, Animation* blendingAnim = new Animation()) #blending anim is generated on anim creation if it exists it plays before anim
Animation Data - (Orientation start, Orientation end, Bone* bone, float startTime, float duration)
Orientation (Rotor) - (float scalar, Bivector bivector)
Bone - (Orientation localOrient, Orientation globalOrient, Bone* parent, Bone** children)

Methods:

Animation -
	play() - plays the animation, if paused resumes, if stopped restarts, if playing resets(? or just keeps going?). if a transition is playing plays that until it finishes no matter what.
	pause() - pauses the animation.
	stop() - stops the animation, if playing also resets, if paused then just resets
	reset() - resets the animation, if playing continues playing.
	seek(float time) - sets the animation timer, like reset, but more powerful.
	isLooping() - returns whether the animation loops
	setLooping(bool looping) - sets whether the animation loops
	onFinish(function action) - sets the action to take when the animation finishes playing (play another animation, make someone else play an animation, bring up a menu, you know, whatever)

	Specifics: Starting from some root bone, calculate the Orientation by blending between the start and end orientation depending on an alpha value dictated by clamp((current time - start time)/duration, 0, 1)
		whenever the alpha value is 1 fire off the finish action and reset timer to 0 (or subtract duration from timer to get the spot in the animation it needs to be in)
		Animation Data will be sorted from earliest start to latest start, the orientation of the bone will be decided by the Animation Data with the latest start time BEFORE the timer value
		every bone child will have its parent bones orientation added on to it, this will be the final orientation for the bone. ALL BONES MUST BE ACCESSIBLE FROM AT LEAST A ROOT BONE.

Animation Data -
	Specifics: no associated methods since these are meant to be interpreted by the animation. These will be output to binary files by an animation editor program.

Bone - 
	Specifics: these will have no associated methods since these are meant to be interpreted by the renderer. Animated Models will attach (reference) Bones to each sub-Model, each sub-Model's Bone will then be attached to Animation Data


Shaders:
Standard uniforms (supported by all shaders by default) will include:
 mouse position
 a global timer (runs from program start)
 a local timer (runs from shader init)
 light positions in the scene
 light colors in the scene
 direction of "sunlight"
 color of "sunlight"
 color of ambient light
 intensity of ambient light

Shader manager
 only one instance of a shader needs to exist on the gpu at any point.
 a shader manager will keep track of compiled shaders and avoid recompilation of already extant shaders.
 underlying structure is an unordered_map, the key is the file name of the shader files, without directory or file extension: for example, "basic" instead of "res/basic.vert" and "res/basic.frag"
 shader files will then have to share filenames and the only distinguishing feature between them would be file extensions: "vert", "frag", "geom", "tess", "comp"

VBOs
 until now, I have been using multiple VBOs to define each object for rendering. 
 This requires (as far as I can tell) multiple VAOs. 
 switching VAOs is costly in the long run and complex.
 a much better solution is putting together everything in one VBO. 
 obviously, this means all objects in that VBO are rendered exactly the same way.
 Mesh objects will no longer store their vertices, that functionality will be transferred to a new ProcMesh object for the sake of simplicity.
 when Mesh objects are created, their vertices are sent to the corresponding buffer on the GPU, we'll have to learn how to manage that memory.
 Meshes will then store their vbo id, their start position in said vbo, and their vertex count. that's it.

 the plan:
  preallocate some space on the gpu (but still support growing the preallocated space)
  when a mesh is created, send the vertices to the preallocated vbo and figure out the start position of these.
  idea: keep a list of the start and end offsets for each mesh in the vbo, when the vbo is reallocated, take that opportunity to defrag memory, otherwise do so when low on allocated memory.
   when a mesh is destroyed, delete it's corresponding entry in the list, when reorganising memory, write over parts not on the list.
  on draw, in glDrawArrays() pass in the start position and vertex count for the current mesh. done.
  
  considerations:
   shaders need to be rebound as well, so it's best to sort by shader, to have all meshes with the same shader render one after the other.
   textures also need to be rebound, so it's best to sort each shader by texture, to minimize texture rebinds.
   this means textures, shaders, and vbos/vaos all need ids. luckily, all of these are assigned ids by opengl, so just sort by those.
   sorting order is as follows, vbo, shader, texture1, texture2, texture3, etc.
   this should minimize rebinds when a few assets are reused many times.

VAOs
 there will be a VAO for each kind of mesh, terrain, particle effects, decorations, objects. done.

Levels
 levels will be made of Cells. 
 Cells are 3D units made of Subcells that are either solid or not. 
 solid Subcells can have a height, they always start from the bottom of the cell.
 visually, Subcells will be constructed from prefab parts made in either some custom tool or Blender.
 there will be default visuals for Subcells as well.
 the default visuals should represent the actual geometry that calculations use.
 default visuals will be:
 a flat cell with top=height.
 a slanted cell in either the X +/- or Z +/- direction with the slant going from the lowest of either height or adjacent height, to the highest of the two.
 walls will stretch from the top of the cell down to the bottom of the cell. this could and should be optimized.
 pits with no Cells below are kill planes.
 pits with Cells below deal damage proportional to the number of empty cells between player and floor.
 if the player lands on a "soft" cell then no damage is taken.
 player is 3.5 units tall.
 player can walk over height differentials of <= 1 unit.
 slants of difference > 1 should be prefab, player can't walk them, I don't care about them.
